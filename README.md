# 📦 Day 4 – Idempotency and Retry Logic in Reactive Spring Boot

This is part of a structured learning series focused on building resilient APIs. In Day 4, we explore how to safely handle retries and prevent duplicate operations using `Idempotency-Key` support in a reactive wallet top-up API.

---

## 🎯 Use Case

You're building a wallet API where users can top up their balance. But what if:

* The user taps "Top Up" and the request times out?
* The app retries — was it already processed?

If retries are not handled correctly, users may be **charged twice**. We fix that.

---

## ✅ What This Project Demonstrates

* Reactive REST endpoint: `POST /api/wallet/topup`
* Accepts client-supplied `Idempotency-Key` header
* Uses an in-memory `ConcurrentHashMap` to detect duplicate requests
* Returns the **same response** for a duplicate key
* Designed to simulate real-world retry behavior

---

## 🧠 Why Idempotency Matters

In distributed systems, retries happen — network failures, timeouts, client crashes.
**Idempotency** ensures that:

* One unique user action = one server-side effect
* No duplicate operations are created by accident

---

## ⚙️ Tech Stack

* Java 17+
* Spring Boot 3.4.x
* Spring WebFlux
* ConcurrentHashMap (in-memory)
* Postman (for testing)

---

## 🚀 How to Run Locally

```bash
git clone https://github.com/atazifor/idempotency.git
cd idempotency
./mvnw spring-boot:run
```

Server runs on: `http://localhost:8080`

---

## 🧪 How to Test in Postman

### 🔁 First Request

```
POST http://localhost:8080/api/wallet/topup
```

### Headers:

```
Idempotency-Key: abc123
Content-Type: application/json
```

### Body:

```json
{
  "userId": "user1",
  "amount": 100.0
}
```

### Second Request (Retry)

Send the **same request again** with the same key. You’ll get the same response, marked:

```json
{
  "duplicate": true
}
```

---

## 🔐 What Is an Idempotency Key?

A **unique identifier** generated by the **client** at the start of a user action ("intent"). It ensures:

* 🔁 Retries return the same result
* 🧾 New keys = new user actions

### Key Rules

* **Same key** → retry
* **Different key** → new intent

### Intent Explained:

> A "user intent" is a deliberate action like tapping "Top Up" — it's not just about same payload, but same purpose.

If the user does the same top-up twice in the day, **use different keys**. If retrying due to a timeout, **use the same key**.

---

## 🧠 Why `ConcurrentHashMap`?

Spring Boot APIs are multi-threaded. A regular `HashMap` isn't thread-safe and can lead to race conditions.

We use `ConcurrentHashMap` to ensure:

* Atomic operations (put/check)
* Safe access under concurrent HTTP requests

---

## 💡 Maven Dependencies (WebFlux)

```xml
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-webflux</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>
```

---

## 📌 What’s Next (Continued in Day 4)

* Simulate retries in Postman Collection Runner
* Add retry logic (Java + exponential backoff)
* Replace in-memory store with Redis or PostgreSQL
* Add expiry policy to stored keys

---

## 📜 License

MIT — free to use, extend, and improve.
